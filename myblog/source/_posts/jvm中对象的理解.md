---
title: JVM中的对象
categories:
  - JVM
tags: JVM
abbrlink: 1e06d641
date: 2021-08-22 22:52:21
---

### 对象的创建

> 我们平常创建对象是通过new关键词来创建的。下面来探索一个对象到底经历了那几个步骤才能被创建。

#### 类加载检查

> 编译期间，JVM会进行类加载的过程，将生成的各种字面量与符号引用，存放到方法区的运行时常量池中。所以，当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程。

#### 为对象分配内存

##### 如何划分可用空间

> 对象所需内存的大小在类加载时就已确定，而根据Java堆是否规整分为2种分配方式
>
> 1. **指针碰撞 ，针对Java堆绝对规整的情况**。假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一 边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那 个指针向空闲空间方向挪动一段与对象大小相等的距离。
> 2. **空闲列表(Free List) ，Java堆不是绝对规整的情况**。如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，
>
> > 总结
> >
> > 当使用Serial、ParNew等带压缩 整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效;而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。

##### 如何保证并发情况下的线程安全

> 因为可能会出现，即使仅仅修改一个指针所指向的位置，可能出现正在给对象 A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。所以JVM使用了TLAB，本地线程分配缓冲，即把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。	

#### 设置对象头

> 主要是类指针、hashcode、GC的分代年龄、锁信息等等

#### 执行 invokespecial

> 执行invokespecial其实就是调用class文件中的init方法，可以看作是一个构造函数。



### 对象内存布局

#### JOL工具的使用

##### 引入依赖

```xml
<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>0.15</version>
  </dependency>
```

##### 建一个User类

```java
@Data
public class User {
    private String name;
    private int age;
}
```

##### 执行代码

```java
 	User user = new User();
  user.setName("demo");
  user.setAge(10);
  log.info(ClassLayout.parseInstance(user).toPrintable());
```

##### 打印如图

<img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-08-25%20%E4%B8%8B%E5%8D%8810.37.22.png" alt="截屏2021-08-25 下午10.37.22" style="zoom:50%;" />

#### 内存布局的划分

> 可见一个对象在堆内存的存储布局被分为三个部分：**对象头、实例数据和对齐填充**

##### 对象头

###### Mark Word

> **Mark Word**：用于存储对象自身的运行时数据，如哈 希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部 分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特

<img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-08-25%20%E4%B8%8B%E5%8D%8810.45.34.png" alt="截屏2021-08-25 下午10.45.34" style="zoom:50%;" />

###### 类型指针

> 类型指针: 即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例

##### 实例数据

> 对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字 段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。例如我们创建的User对象中的name和age字段。

##### 对齐填充

> 这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作 用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是 任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数(1倍或者 2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

