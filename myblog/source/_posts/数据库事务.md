---
title: 数据库事务
categories:
  - 数据库
  - 事务
tags: 数据库
abbrlink: '587418e1'
date: 2021-03-24 22:52:21
---
### 事务

> 什么是事务？

要么都成功，要么都失败。

#### ACID原则

> 关系型数据库支持事务的 ACID 原则，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）

##### 原子性(Atomicity)

要么都成功，要么都失败。

##### 一致性(Consistency)

一致性是指在事务开始之前和事务结束以后，数据完整性要保持一致。

比如A给B转账，事务前后A和B的总金额是一样的，这就是最终一致性。

##### 隔离性(Isolation)

事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不会被其他事务的操作数据所干扰。

##### 持久性(Durability)

事务一旦提交则不可逆，被持久化到数据库中

#### 并发一致性问题

> 在并发环境下，多个事务在执行操作，事务的隔离性很难保证，因此会出现很多并发一致性问题。
<!--more-->
##### 脏读

> 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

```sql
例如：
张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。
与此同时，
事务B正在读取张三的工资，读取到张三的工资为8000。
随后，
事务A发生异常，而回滚了事务。张三的工资又回滚为5000。
最后，
事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。
```

##### 幻读

> 事务读取数据后，另一个事务新增或删除了一条记录，导致查询出来的结果跟前一次不一样。

```SQL
例如：
目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。
此时，
事务B插入一条工资也为5000的记录。
这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。
```

##### 不可重复读

> 一个事务多次读同一个数据，中间另一个事务提交并修改了数据，会造成多次读到的数据不一样。

```sql
例如：
在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。
与此同时，
事务B把张三的工资改为8000，并提交了事务。
随后，
在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。
```

**注意：**

**虽然都是读取了未提交的数据，但脏读的重点是修改，幻读的重点在于新增或者删除；而不可重复读是读取了另一个事务已提交的数据，看着没错但是事务不应该互相影响 **

##### 第一类丢失更新

>A和B访问修改同一个数据，A事务撤消时，把已提交的B事务的数据覆盖掉

##### 第二类丢失更新

>A和B访问修改同一个数据，A事务提交时，把已提交的B事务的数据覆盖掉



#### 封锁

>封锁就是事务T在对某个数据对象（例如表记录等）操作前先向系统发起请求，对其加锁。
>
>在事务T释放锁之前，其他事务不能更新此数据对象。
>
>封锁是实现并发控制的一个非常重要的技术。

##### 基本封锁类型

###### 排他锁(X锁/写锁)

> INNODB中锁的概念。释放锁之前，其他事务不能读取和修改加锁的数据

###### 共享锁(S锁/读锁)

> INNODB中锁的概念。释放锁之前，其他事务可以读取但不能修改加锁的数据

###### 锁的相容性

| -    | X    | S    |
| ---- | ---- | ---- |
| X    | N    | N    |
| S    | N    | Y    |

###### 扩展和补充

>#### 表锁(偏读)
>
>###### 由于MYISAM只支持表锁，INNODB支持表锁和行锁。所以MYISAM和INNODB中表锁的情况都一致。
>
>查看加锁的表：`show open tables`
>
>加锁命令：`lock table [表名][read/write]`
>
>释放锁命令：`unlock tables`
>
>如何分析表锁
>
>* > 执行`show status like 'table%'`
> >
> > 查看``Table_locks_waited`  ，表示产生锁争用而发生等待的次数，没等待一次锁值加1。值越高说明表锁争用情况严重。
>
>##### 会话1给A表加写锁，则只能读和写A表，不能读其他未加读锁的表。会话2不能读到A表，会一直阻塞，直到A表的写锁释放。
>
>##### 会话1给A表加读锁，则只能读A表，不能读其他未加读锁的表，且不能修改A表。会话2可以读到A表，但是更新A表时会一直阻塞，直到A表的读锁释放。
>
>### 行锁(偏写)
>
>行锁的特点是：
>
>* 开销大、加锁慢；会出现死锁；锁粒度最小，发生锁冲突的概率最低，并发度也最高。
>
>##### INNODB与MYISAM最大不同有2点：`支持事务`和`采用行级锁`
>
>可以看出，行锁是支持事务的。
>
>##### 如何手动锁定一行
>
>> ```
>> begin;
>> ...... for update;
>> commit;
>> ```
>>
>> 此时其他会话要修改这行的数据，会发生阻塞，直到`commit`
>
>##### 什么情况下行锁变表锁？
>
>比如（演示前要先`set autocommit=0;`）： 
>
>会话1`update A set NAME=100 where ID=1; ` NAME `VARCHAR` 类型没有使用单引号.
>
>会话2 `select * from A where ID=1 `。此时由于会话1内部产生了自动类型转换造成**索引失效**，导致表锁。如果会话1不`commit`会一直阻塞。
>
>#### 间隙锁
>
>> 演示前要先`set autocommit=0;`。
>>
>> 会话1：`select * from A where id >1 and id <8。` 假设A表没有id=6的记录。
>>
>> 会话2： `insert into A values (6，.....)`。此时插入id=6的记录，会发生阻塞。即发生了间隙锁。
>>
>> ##### 当我们用范围条件检索数据，并请求共享锁或排他锁时，`Innodb`会给符合条件的已有数据记录的索引项加锁。在范围条件内但并不存在的记录，叫做“间隙”。`Innodb`也会对间隙加锁。在某种场景下间隙锁造成的阻塞，会对性能造成很大影响。

##### 封锁协议之三级封锁协议

> 解决了并发一致性问题。

###### 一级封锁协议

> 事务在修改数据之前必须对数据加**X锁**，直到释放锁

1.  一级封锁协议可防止丢失修改，并保证事务T是可恢复的
2.  读数据不需要加读锁，不能解决不可重复读和脏读问题

###### 二级封锁协议

> 在一级封锁协议基础上，在读取数据前要加读锁，读完后即释放锁

1. 可以防止丢失修改和脏读

![](images/数据库/二级封锁.png)

###### 三级封锁协议

> 在一级封锁协议基础上，读取数据要加读锁，直到事务结束才释放

1. 三级封锁协议可防止丢失修改、脏读和不可重复读

![](images/数据库/三级封锁.png)

###### 三种协议的对比

![](images/数据库/三协议对比.png)

##### 封锁协议之两段锁协议

>加锁和解锁阶分为两个阶段进行。
>
>内容：
>
>1. 在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁
>2. 在释放一个封锁之后，事务不再获得其他封锁
>
>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。
>
>lock-x(A)…lock-s(B)…lock-s(C)…unlock(A)…unlock(C)…unlock(B)
>
>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。
>
>lock-x(A)…unlock(A)…lock-s(B)…unlock(B)…lock-s(C)…unlock(C)

##### 封锁带来的问题

###### 活锁

> 系统可能是某个事务永远处于等待状态，得不到封锁的机会

![](images/数据库/活锁.png)

如何避免？先来先服务策略

###### 死锁

![](images/数据库/死锁.png)

#### 事务隔离级别

> 为了解决上述问题，数据库通过**锁机制**解决并发访问的问题。根据锁定对象不同：分为行级锁和表级锁；根据并发事务锁定的关系上看：分为共享锁和排它锁，共享锁会防止排它锁但允许其他的共享锁。而排它锁既防止共享锁也防止其他排它锁。为了更改数据，数据库必须在进行更改的行上施加行排它锁，insert、update、delete和select for update语句都会隐式采用必要的行锁定。
>
> 但是直接使用锁机制管理是很复杂的，基于锁机制，数据库给用户提供了不同的**事务隔离级别**，只要设置了事务隔离级别，数据库就会分析事务中的sql语句然后自动选择合适的锁。 

##### **读未提交**

> 读未提交(READ_UNCOMMITTED)，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用

##### **读已提交**

> 读已提交(READ_COMMITED)，即能够读到那些已经提交的数据，能够防止脏读，但是无法限制不可重复读和幻读

##### **可重复读**

> 可重复读(REPEATABLE_READ)，即在数据读出来之后加锁，类似"select * from XXX for update"，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决

##### **串行化**

> 串行化(SERLALIZABLE)，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务。比如幻读，事务A的插入或删除操作必须等待事务B的事务结束后才会进行，否则会一直阻塞。这样就解决了脏读、不可重复读和幻读的问题了。但缺点是性能十分低下。

不同数据库默认的隔离级别是不同的。mysql支持四种隔离级别,默认隔离级别是`REPEATABLE_READ`,oracle支持`READ_COMMITED`和`SERLALIZABLE`,默认隔离级别是`READ_COMMITED`。

#### MVCC

> 多版本并发控制(Multi-Version Concurrentcy control)的简称，针对读已提交和可重复读
>
> 通过记录多个修改的历史版本替代锁，实现事务间的隔离效果，保证非阻塞读！
>
> 实现核心为三点
>
> * 表的隐藏列：记录事务ID及上个版本数据地址，即事务ID **trix_id**和回滚指针**roll_pointer**
> * undo log: 记录数据各版本修改历史即事务链，生成undo日志的时候会带上隐藏列
> * read view: 读视图，用于判断哪些版本可见

