## 数据库

### 事务

> 什么是事务？

要么都成功，要么都失败。

#### ACID原则

> 关系型数据库支持事务的 ACID 原则，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）

##### 原子性(Atomicity)

要么都成功，要么都失败。

##### 一致性(Consistency)

一致性是指在事务开始之前和事务结束以后，数据完整性要保持一致。

比如A给B转账，事务前后A和B的总金额是一样的，这就是最终一致性。

##### 隔离性(Isolation)

事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不会被其他事务的操作数据所干扰。

##### 持久性(Durability)

事务一旦提交则不可逆，被持久化到数据库中

#### 并发一致性问题

> 在并发环境下，多个事务在执行操作，事务的隔离性很难保证，因此会出现很多并发一致性问题。

##### 脏读

> 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

```sql
例如：
张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。
与此同时，
事务B正在读取张三的工资，读取到张三的工资为8000。
随后，
事务A发生异常，而回滚了事务。张三的工资又回滚为5000。
最后，
事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。
```

##### 幻读

> 事务读取数据后，另一个事务新增或删除了一条记录，导致查询出来的结果跟前一次不一样。

```SQL
例如：
目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。
此时，
事务B插入一条工资也为5000的记录。
这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。
```

##### 不可重复读

> 一个事务多次读同一个数据，中间另一个事务修改了数据，会造成多次读到的数据不一样。

```sql
例如：
在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。
与此同时，
事务B把张三的工资改为8000，并提交了事务。
随后，
在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。
```

**注意：不可重复读的重点是修改： 
同样的条件，你读取过的数据，再次读取出来发现值不一样了
幻读的重点在于新增或者删除： 
同样的条件，第 1 次和第 2 次读出来的记录数不一样**

##### 第一类丢失更新

>A和B访问修改同一个数据，A事务撤消时，把已提交的B事务的数据覆盖掉

##### 第二类丢失更新

>A和B访问修改同一个数据，A事务提交时，把已提交的B事务的数据覆盖掉



#### 封锁

>封锁就是事务T在对某个数据对象（例如表记录等）操作前先向系统发起请求，对其加锁。
>
>在事务T释放锁之前，其他事务不能更新此数据对象。
>
>封锁是实现并发控制的一个非常重要的技术。

##### 基本封锁类型

###### 排他锁(X锁/写锁)

> 释放锁之前，其他事务不能读取和修改加锁的数据

###### 共享锁(S锁/读锁)

> 释放锁之前，其他事务可以读取但不能修改加锁的数据

###### 锁的相容性

| -    | X    | S    |
| ---- | ---- | ---- |
| X    | N    | N    |
| S    | N    | Y    |

##### 封锁协议之三级封锁协议

> 解决了并发一致性问题。

###### 一级封锁协议

> 事务在修改数据之前必须对数据加**X锁**，直到释放锁

1.  一级封锁协议可防止丢失修改，并保证事务T是可恢复的
2. 读数据不需要加读锁，不能解决不可重复读和脏读问题

###### 二级封锁协议

> 在一级封锁协议基础上，在读取数据前要加读锁，读完后即释放锁

1. 可以防止丢失修改和脏读

![image-20210309230054977](I:\2021\Hexo\md\二级封锁.png)

###### 三级封锁协议

> 在一级封锁协议基础上，读取数据要加读锁，直到事务结束才释放

1. 三级封锁协议可防止丢失修改、脏读和不可重复读

![image-20210309230435602](I:\2021\Hexo\md\三级封锁.png)

###### 三种协议的对比

![image-20210309230643286](I:\2021\Hexo\md\三协议对比.png)



##### 封锁协议之两段锁协议

>加锁和解锁阶分为两个阶段进行。
>
>内容：
>
>1. 在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁
>2. 在释放一个封锁之后，事务不再获得其他封锁
>
>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。
>
>lock-x(A)…lock-s(B)…lock-s(C)…unlock(A)…unlock(C)…unlock(B)
>
>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。
>
>lock-x(A)…unlock(A)…lock-s(B)…unlock(B)…lock-s(C)…unlock(C)

##### 封锁带来的问题

###### 活锁

> 系统可能是某个事务永远处于等待状态，得不到封锁的机会

![image-20210309232459565](I:\2021\Hexo\md\活锁.png)

如何避免？先来先服务策略

###### 死锁

![image-20210309232742690](I:\2021\Hexo\md\死锁.png)

#### 事务隔离级别

> 为了解决上述问题，数据库通过**锁机制**解决并发访问的问题。根据锁定对象不同：分为行级锁和表级锁；根据并发事务锁定的关系上看：分为共享锁和排它锁，共享锁会防止排它锁但允许其他的共享锁。而排它锁既防止共享锁也防止其他排它锁。为了更改数据，数据库必须在进行更改的行上施加行排它锁，insert、update、delete和select for update语句都会隐式采用必要的行锁定。
>
> 但是直接使用锁机制管理是很复杂的，基于锁机制，数据库给用户提供了不同的**事务隔离级别**，只要设置了事务隔离级别，数据库就会分析事务中的sql语句然后自动选择合适的锁。 

##### **读未提交 **

> 读未提交(READ_UNCOMMITTED)，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用

##### **读已提交**

> 读已提交(READ_COMMITED)，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读

##### **可重复读**

> 可重复读(REPEATABLE_READ)，即在数据读出来之后加锁，类似"select * from XXX for update"，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决

##### **串行化**

> 串行化(SERLALIZABLE)，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了



